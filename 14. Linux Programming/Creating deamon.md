# What is Deamon:
# How to create Deamon:
1. Fork child process and parent process exit: 
```
/* Fork off for the second time*/
    int pid = fork();

    /* An error occurred */
    if (pid < 0)
        exit(EXIT_FAILURE);
    /* Success: Let the parent terminate */
    if (pid > 0)                        /* parent codes */
        exit(EXIT_SUCCESS);
    else if (pid == 0){                 /* child process code */  
    }
```
* If PID > 0: process ID of child is returned to parent process, the codes after is run by parent process. It is required to kill parent process
* if PID =0: the value return to child process, the codes after is run by child process. 
    * after parent process is killed, `init` (process 1) inherits the child and becomes its parent.
* if PID<0: failure to fork.
2. Make child process session leader via setsid()
3. Change directory `chdir("/")`
* child process created with fork inherits the current working directory of the parent process. Since the file system in which the current directory is located (e.g., "/mnt/usb") cannot be unmounted while the process is running.
4. Unmask file `umask(0)`
### Ref: 
* https://ofstack.com/C++/28351/c++-write-linux-daemon-implementation-code.html 
* https://notes.shichao.io/apue/ch13/ 
# What is the purpose of controlling terminal? why is it closed for the child process that runs deamon?
* With controlling terminal, process is able to tell kernel which process group is foreground process group (in same session). If there is a foreground process group for a terminal, we can control the foreground process group via the terminal, e.g., Ctrl-C/Ctrl-\ to terminate the foreground process group. With controlling terminal, even if you already redirect stdin to other places/files, you still be able to read/write from/to controlling terminal, the `/dev/tty`. This special file is a synonym within the kernel for the controlling terminal of current process. What can you do regarding this file? E.g., some programs need user to input password before doing something, such as programs for login or encryption. These programs may prohibit user from inputting password from stdin, which means even if you redirect their stdin to a random file, they'll still wait for your type. The reason is they all open /dev/tty to read.
* For a deamon, it is unnessary to associate with a controlling terminal, doesn't need to read/write from `/dev/tty`
* A process relinquishes its controlling terminal when it creates a new session with the setsid(). Other processes remaining in the old session that had this terminal as their controlling terminal continue to have it. When a controlling process terminates, the controlling terminal is dissociated from the current session, allowing it to be acquired by a new session leader.
### Ref:
* Ref: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html#tag_11_01_03
* Ref: https://unix.stackexchange.com/questions/404555/what-is-the-purpose-of-the-controlling-terminal
# Process Group vs Session
* `Session > Process Group > Process > Threads`
* A **process group** is a collection of related processes which can all be signalled at once.
    * A terminal may have a foreground process group associated with it.
    * If a process is in the *foreground* process group of its controlling terminal, read/write operations shall be allowed.
* A **session** is a collection of process groups, which are either attached to a single terminal device (known as the controlling terminal) or not attached to any terminal.
    * Sessions are used for job control: one of the process groups in the session is the foreground process group, and can be sent signals by terminal control characters
# Foreground Process vs Background Process
* **Foreground Process**: shell will wait until other process finish. For c coding, it is same as wait().
    * Among the process groups in a session, at most one can be the foreground process group of that session. 
    * The tty input and tty signals (signals generated by ^C, ^Z, etc.) go to processes in this foreground process group.
* **Background Process**: shell will continues while other processes execute.
    * `&` is shell syntax for running a process in the background.
### Ref:
* Explaining Foreground vs Background, Process: https://www.win.tue.nl/~aeb/linux/lk/lk-10.html
